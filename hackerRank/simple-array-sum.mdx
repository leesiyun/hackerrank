# Simple Array Sum

🔗 [problem](https://www.hackerrank.com/challenges/simple-array-sum/problem?isFullScreen=true)

정수 배열이 주어지면 해당 요소의 합을 찾습니다.  
예를 들어 배열이 `ar = [1, 2, 3]`이면 `1 + 2, + 3 = 6` 배열 안의 숫자를 더해서 `6`을 반환합니다.

<br />

## 기능 설명

아래 편집기에서 simpleArraySum 함수를 완성하세요. 배열 요소의 합계를 정수로 반환해야 합니다.  
simpleArraySum에는 다음 매개 변수가 있습니다.

- ar : 정수 배열

<br />

## 입력 형식

첫 번째 줄은 정수를 포함하고, `n`은 배열의 크기를 나타냅니다.
두 번째 줄에는 `n` 배열의 요소를 나타내는 공백으로 구분된 정수입니다..

<br />

## 제약

```
0 ≤ n, ar[i] ≤ 1000
```

<br />

## 출력 형식

배열 요소의 합을 단일 정수로 출력합니다.

<br />

## 샘플 입력

```
6
1 2 3 4 10 11
```

<br />

## 샘플 출력

```
31
```

<br />

## 설명

```
1 + 2 + 3 + 4 + 10 + 11 = 31
```

## solution

```JS
const simpleArraySum = (ar) => ar.reduce((acc, cur) => acc + cur, 0);
// const constraintCheck = (n, ar) => n > 0 && n <= 1000 && ar.every((i) => i > 0 && i <= 1000);
```

## 작성 코드에 대한 고찰

**reduce 초기값에 대하여**
`ar.reduce((acc, cur) => acc + cur, 0)` 에서 어차피 더하기인데 초기값을 제거하고 `ar.reduce((acc, cur) => acc + cur)`라고 작성해도 좋을지 여부에 대해 알아봅니다.
MDN 도큐멘트 `Array.prototype.reduce()에 따르면`(아래 지식쌓기 Array.prototype.reduce() 부분 참고) 콜백이 최초 호출할때 acc와 cur는 다음 두 가지 값중 하나를 같습니다.
초기 값을 제공한 경우, acc는 초기 값이고 cur는 배열의 첫 번째 값이 되고, 초기 값이 제공하지 않았다면, acc는 배열의 첫 번째 값과 같고, cur는 배열의 두번째 값입니다.

이번 알고리즘은 문제는 배열의 첫 번째 값부터 마지막 값까지의 합이므로, 0을 제외하고 작성해도 좋았다고 생각합니다.

**수정해본 코드**

```JS
const simpleArraySum = (ar) => ar.reduce((acc, cur) => acc + cur);
```

## 지식 쌓기

### Array.prototype.every()

[Array.prototype.every()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/every)

<br />

### Array.prototype.some()

[Array.prototype.some()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/some)

<br />

### Array.prototype.reduce()

[Array.prototype.reduce()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)

`reduce()` 메서드는 배열의 각 요소에 대해 주어진 리듀서(reducer) 함수를 실행하고, 하나의 결과값을 반환합니다.

리듀서 함수는 네 개의 인자를 가집니다.

1. 누산기 (acc)
2. 현재 값 (cur)
3. 현재 인덱스 (idx)
4. 원본 배열(src)

콜백이 최초 호출 때 `accumulator`와 `currentValue`는 다음 두 가지 값 중 하나를 가질 수 있습니다.  
만약 `reduce()` 함수 호출에서 `initialValue`를 제공한 경우, `accumulator`는 initialValue와 같고 `currentValue`는 배열의 첫 번째 값과 같습니다.  
`initialValue`를 제공하지 않았다면, `accumulator`는 배열의 첫 번째 값과 같고 `currentValue`는 두 번째와 같습니다.

참고 : intialValue를 제공하지 않으면, `reduce()`는 인덱스 1부터 시작해 콜백 함수를 실행하고 첫 번째 인덱스는 건너 뜁니다. initialValue를 제공하면 인덱스 0에서 시작합니다.

배열이 비어있는데 initialValue도 제공하지 않으면 TypeError가 발생합니다. 배열의 요소가 (위치와 관계없이) 하나 뿐이면서 initialValue를 제공되지 않은 경우, 또는 initialValue가 주어졌으나 배열이 빈 경우에는 그 단독 값을 callback 호출 없이 반홥합니다.

다음 예제처럼 initialValue을 제공하지 않으면 출력 가능한 형식이 세 가지이므로, 보통 초기 값을 주는 것이 더 안전합니다.

```JS
var maxCallback = ( acc, cur ) => Math.max( acc.x, cur.x );
var maxCallback2 = ( max, cur ) => Math.max( max, cur );

// initialValue 없이 reduce()
[ { x: 22 }, { x: 42 } ].reduce( maxCallback ); // 42
[ { x: 22 }            ].reduce( maxCallback ); // { x: 22 }
[                      ].reduce( maxCallback ); // TypeError

// map/reduce로 개선 - 비었거나 더 큰 배열에서도 동작함
[ { x: 22 }, { x: 42 } ].map( el => el.x )
                        .reduce( maxCallback2, -Infinity );
```

<br />
